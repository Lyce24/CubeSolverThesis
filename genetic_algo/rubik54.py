from enum import IntEnum
import random
import concurrent.futures
import time
import numpy as np

class Facelet(IntEnum):
    """""
    The names of the facelet positions of the cube
                  |************|
                  |*U1**U2**U3*|
                  |************|
                  |*U4**U5**U6*|
                  |************|
                  |*U7**U8**U9*|
                  |************|
     |************|************|************|************|
     |*L1**L2**L3*|*F1**F2**F3*|*R1**R2**R3*|*B1**B2**B3*|
     |************|************|************|************|
     |*L4**L5**L6*|*F4**F5**F6*|*R4**R5**R6*|*B4**B5**B6*|
     |************|************|************|************|
     |*L7**L8**L9*|*F7**F8**F9*|*R7**R8**R9*|*B7**B8**B9*|
     |************|************|************|************|
                  |************|
                  |*D1**D2**D3*|
                  |************|
                  |*D4**D5**D6*|
                  |************|
                  |*D7**D8**D9*|
                  |************|
    A cube definition string "UBL..." means for example: In position U1 we have the U-color, in position U2 we have the
    B-color, in position U3 we have the L color etc. according to the order U1, U2, U3, U4, U5, U6, U7, U8, U9, R1, R2,
    R3, R4, R5, R6, R7, R8, R9, F1, F2, F3, F4, F5, F6, F7, F8, F9, D1, D2, D3, D4, D5, D6, D7, D8, D9, L1, L2, L3, L4,
    L5, L6, L7, L8, L9, B1, B2, B3, B4, B5, B6, B7, B8, B9 of the enum constants.
    """
    U1 = 0
    U2 = 1
    U3 = 2
    U4 = 3
    U5 = 4
    U6 = 5
    U7 = 6
    U8 = 7
    U9 = 8
    R1 = 9
    R2 = 10
    R3 = 11
    R4 = 12
    R5 = 13
    R6 = 14
    R7 = 15
    R8 = 16
    R9 = 17
    F1 = 18
    F2 = 19
    F3 = 20
    F4 = 21
    F5 = 22
    F6 = 23
    F7 = 24
    F8 = 25
    F9 = 26
    D1 = 27
    D2 = 28
    D3 = 29
    D4 = 30
    D5 = 31
    D6 = 32
    D7 = 33
    D8 = 34
    D9 = 35
    L1 = 36
    L2 = 37
    L3 = 38
    L4 = 39
    L5 = 40
    L6 = 41
    L7 = 42
    L8 = 43
    L9 = 44
    B1 = 45
    B2 = 46
    B3 = 47
    B4 = 48
    B5 = 49
    B6 = 50
    B7 = 51
    B8 = 52
    B9 = 53


class Color(IntEnum):
    """ The possible colors of the cube facelets. Color U refers to the color of the U(p)-face etc.
    Also used to name the faces itself."""
    U = 0
    R = 1
    F = 2
    D = 3
    L = 4
    B = 5


class Corner(IntEnum):
    """The names of the corner positions of the cube. Corner URF e.g. has an U(p), a R(ight) and a F(ront) facelet."""
    URF = 0
    UFL = 1
    ULB = 2
    UBR = 3
    DFR = 4
    DLF = 5
    DBL = 6
    DRB = 7


class Edge(IntEnum):
    """The names of the edge positions of the cube. Edge UR e.g. has an U(p) and R(ight) facelet."""
    UR = 0
    UF = 1
    UL = 2
    UB = 3
    DR = 4
    DF = 5
    DL = 6
    DB = 7
    FR = 8
    FL = 9
    BL = 10
    BR = 11


class Move(IntEnum):
    """The moves in the faceturn metric. Not to be confused with the names of the facelet positions in class Facelet."""
    U1 = 0 # U(p) face clockwise
    U3 = 1 # U(p) face counter-clockwise
    R1 = 2
    R3 = 3
    F1 = 4
    F3 = 5
    D1 = 6
    D3 = 7
    L1 = 8
    L3 = 9
    B1 = 10
    B3 = 11
    N = -1  # Null move


class BS(IntEnum):
    """Basic symmetries of the cube. All 48 cube symmetries can be generated by sequences of these 4 symmetries."""
    ROT_URF3 = 0
    ROT_F2 = 1
    ROT_U4 = 2
    MIRR_LR2 = 3

# Map the corner positions to facelet positions.
cornerFacelet = [[Facelet.U9, Facelet.R1, Facelet.F3], [Facelet.U7, Facelet.F1, Facelet.L3], [Facelet.U1, Facelet.L1, Facelet.B3], [Facelet.U3, Facelet.B1, Facelet.R3],
                 [Facelet.D3, Facelet.F9, Facelet.R7], [Facelet.D1, Facelet.L9, Facelet.F7], [Facelet.D7, Facelet.B9, Facelet.L7], [Facelet.D9, Facelet.R9, Facelet.B7]
                 ]

# Map the edge positions to facelet positions.
edgeFacelet = [[Facelet.U6, Facelet.R2], [Facelet.U8, Facelet.F2], [Facelet.U4, Facelet.L2], [Facelet.U2, Facelet.B2], [Facelet.D6, Facelet.R8], [Facelet.D2, Facelet.F8],
               [Facelet.D4, Facelet.L8], [Facelet.D8, Facelet.B8], [Facelet.F6, Facelet.R4], [Facelet.F4, Facelet.L6], [Facelet.B6, Facelet.L4], [Facelet.B4, Facelet.R6]
               ]

# Map the corner positions to facelet colors.
cornerColor = [[Color.U, Color.R, Color.F], [Color.U, Color.F, Color.L], [Color.U, Color.L, Color.B], [Color.U, Color.B, Color.R],
               [Color.D, Color.F, Color.R], [Color.D, Color.L, Color.F], [Color.D, Color.B, Color.L], [Color.D, Color.R, Color.B]
               ]

# Map the edge positions to facelet colors.
edgeColor = [[Color.U, Color.R], [Color.U, Color.F], [Color.U, Color.L], [Color.U, Color.B], [Color.D, Color.R], [Color.D, Color.F],
             [Color.D, Color.L], [Color.D, Color.B], [Color.F, Color.R], [Color.F, Color.L], [Color.B, Color.L], [Color.B, Color.R]
             ]

move_dict = {
    Move.U1: "U",
    Move.U3: "U'",
    Move.R1: "R",
    Move.R3: "R'",
    Move.F1: "F",
    Move.F3: "F'",
    Move.D1: "D",
    Move.D3: "D'",
    Move.L1: "L",
    Move.L3: "L'",
    Move.B1: "B",
    Move.B3: "B'",
    Move.N: "N"
}

color_dict = {
    0 : [1, 0, 0, 0, 0, 0],
    1 : [0, 1, 0, 0, 0, 0],
    2 : [0, 0, 1, 0, 0, 0],
    3 : [0, 0, 0, 1, 0, 0],
    4 : [0, 0, 0, 0, 1, 0],
    5 : [0, 0, 0, 0, 0, 1]
}

class FaceCube:
    """Represent a cube on the facelet level with 54 colored facelets."""
    def __init__(self):
        self.f = []
        for i in range(9):
            self.f.append(Color.U)
        for i in range(9):
            self.f.append(Color.R)
        for i in range(9):
            self.f.append(Color.F)
        for i in range(9):
            self.f.append(Color.D)
        for i in range(9):
            self.f.append(Color.L)
        for i in range(9):
            self.f.append(Color.B)

    def __str__(self):
        return self.to_string()
    
    def move(self, move: Move):
        if move == Move.U1:
            # U face
            self._rotate_face(Color.U)
                        
            # adjacent faces
            temp = self.f[Facelet.F1:Facelet.F4]
            self.f[Facelet.F1:Facelet.F4] = self.f[Facelet.R1:Facelet.R4]
            self.f[Facelet.R1:Facelet.R4] = self.f[Facelet.B1:Facelet.B4]
            self.f[Facelet.B1:Facelet.B4] = self.f[Facelet.L1:Facelet.L4]
            self.f[Facelet.L1:Facelet.L4] = temp
        elif move == Move.U3:
            self.move(Move.U1)
            self.move(Move.U1)
            self.move(Move.U1)
            
        elif move == Move.R1:
            # R face
            self._rotate_face(Color.R)
            
            # adjacent faces
            self.f[Facelet.U3], self.f[Facelet.U6], self.f[Facelet.U9], self.f[Facelet.F3], self.f[Facelet.F6], self.f[Facelet.F9], self.f[Facelet.D3], self.f[Facelet.D6], self.f[Facelet.D9], self.f[Facelet.B7], self.f[Facelet.B4], self.f[Facelet.B1] = self.f[Facelet.F3], self.f[Facelet.F6], self.f[Facelet.F9], self.f[Facelet.D3], self.f[Facelet.D6], self.f[Facelet.D9], self.f[Facelet.B7], self.f[Facelet.B4], self.f[Facelet.B1], self.f[Facelet.U3], self.f[Facelet.U6], self.f[Facelet.U9]
        elif move == Move.R3:
            self.move(Move.R1)
            self.move(Move.R1)
            self.move(Move.R1)
            
        elif move == Move.F1:
            # F face
            self._rotate_face(Color.F)
            
            # adjacent faces
            self.f[Facelet.U7], self.f[Facelet.U8], self.f[Facelet.U9], self.f[Facelet.R1], self.f[Facelet.R4], self.f[Facelet.R7], self.f[Facelet.D1], self.f[Facelet.D2], self.f[Facelet.D3], self.f[Facelet.L3], self.f[Facelet.L6], self.f[Facelet.L9] = self.f[Facelet.L9], self.f[Facelet.L6], self.f[Facelet.L3], self.f[Facelet.U7], self.f[Facelet.U8], self.f[Facelet.U9], self.f[Facelet.R7], self.f[Facelet.R4], self.f[Facelet.R1], self.f[Facelet.D1], self.f[Facelet.D2], self.f[Facelet.D3]
        elif move == Move.F3:
            self.move(Move.F1)
            self.move(Move.F1)
            self.move(Move.F1)
            
        # D moves
        elif move == Move.D1:
            # D face
            self._rotate_face(Color.D)
            
            # adjacent faces
            temp = self.f[Facelet.F7], self.f[Facelet.F8], self.f[Facelet.F9]
            self.f[Facelet.F7], self.f[Facelet.F8], self.f[Facelet.F9] = self.f[Facelet.L7], self.f[Facelet.L8], self.f[Facelet.L9]
            self.f[Facelet.L7], self.f[Facelet.L8], self.f[Facelet.L9] = self.f[Facelet.B7], self.f[Facelet.B8], self.f[Facelet.B9]
            self.f[Facelet.B7], self.f[Facelet.B8], self.f[Facelet.B9] = self.f[Facelet.R7], self.f[Facelet.R8], self.f[Facelet.R9]
            self.f[Facelet.R7], self.f[Facelet.R8], self.f[Facelet.R9] = temp
        elif move == Move.D3:
            self.move(Move.D1)
            self.move(Move.D1)
            self.move(Move.D1)
            
        # L moves
        elif move == Move.L1:
            # L face
            self._rotate_face(Color.L)
            
            # adjacent faces
            temp = [self.f[Facelet.U1], self.f[Facelet.U4], self.f[Facelet.U7]]
            self.f[Facelet.U1], self.f[Facelet.U4], self.f[Facelet.U7] = self.f[Facelet.B9], self.f[Facelet.B6], self.f[Facelet.B3]
            self.f[Facelet.B9], self.f[Facelet.B6], self.f[Facelet.B3] = self.f[Facelet.D1], self.f[Facelet.D4], self.f[Facelet.D7]
            self.f[Facelet.D1], self.f[Facelet.D4], self.f[Facelet.D7] = self.f[Facelet.F1], self.f[Facelet.F4], self.f[Facelet.F7]
            self.f[Facelet.F1], self.f[Facelet.F4], self.f[Facelet.F7] = temp
        elif move == Move.L3:
            self.move(Move.L1)
            self.move(Move.L1)
            self.move(Move.L1)
            
        # B moves
        elif move == Move.B1:
            # B face
            self._rotate_face(Color.B)
            
            # adjacent faces
            temp = [self.f[Facelet.U1], self.f[Facelet.U2], self.f[Facelet.U3]]
            self.f[Facelet.U1], self.f[Facelet.U2], self.f[Facelet.U3] = self.f[Facelet.R3], self.f[Facelet.R6], self.f[Facelet.R9]
            self.f[Facelet.R3], self.f[Facelet.R6], self.f[Facelet.R9] = self.f[Facelet.D9], self.f[Facelet.D8], self.f[Facelet.D7]
            self.f[Facelet.D9], self.f[Facelet.D8], self.f[Facelet.D7] = self.f[Facelet.L7], self.f[Facelet.L4], self.f[Facelet.L1]
            self.f[Facelet.L7], self.f[Facelet.L4], self.f[Facelet.L1] = temp
        elif move == Move.B3:
            self.move(Move.B1)
            self.move(Move.B1)
            self.move(Move.B1)
        
        elif move == Move.N:
            return
        
        else:
            raise ValueError('Invalid move: ' + str(move))
        
    def _rotate_face(self, face):
        """Rotate a face clockwise."""
        offset = face * 9
        new_f = self.f[offset:offset+9]  # Copy the face
        self.f[offset + 0] = new_f[6]
        self.f[offset + 2] = new_f[0]
        self.f[offset + 6] = new_f[8]
        self.f[offset + 8] = new_f[2]
        
        self.f[offset + 1] = new_f[3]
        self.f[offset + 3] = new_f[7]
        self.f[offset + 5] = new_f[1]
        self.f[offset + 7] = new_f[5]
            
    def from_string(self, s):
        """Construct a facelet cube from a string. See class Facelet(IntEnum) in enums.py for string format."""
        if len(s) < 54:
            return 'Error: Cube definition string ' + s + ' contains less than 54 facelets.'
        elif len(s) > 54:
            return 'Error: Cube definition string ' + s + ' contains more than 54 facelets.'
        cnt = [0] * 6
        for i in range(54):
            if s[i] == 'U':
                self.f[i] = Color.U
                cnt[Color.U] += 1
            elif s[i] == 'R':
                self.f[i] = Color.R
                cnt[Color.R] += 1
            elif s[i] == 'F':
                self.f[i] = Color.F
                cnt[Color.F] += 1
            elif s[i] == 'D':
                self.f[i] = Color.D
                cnt[Color.D] += 1
            elif s[i] == 'L':
                self.f[i] = Color.L
                cnt[Color.L] += 1
            elif s[i] == 'B':
                self.f[i] = Color.B
                cnt[Color.B] += 1
        if all(x == 9 for x in cnt):
            return True
        else:
            return 'Error: Cube definition string ' + s + ' does not contain exactly 9 facelets of each color.'

    def to_string(self):
        """Give a string representation of the facelet cube."""
        s = ''
        for i in range(54):
            if self.f[i] == Color.U:
                s += 'U'
            elif self.f[i] == Color.R:
                s += 'R'
            elif self.f[i] == Color.F:
                s += 'F'
            elif self.f[i] == Color.D:
                s += 'D'
            elif self.f[i] == Color.L:
                s += 'L'
            elif self.f[i] == Color.B:
                s += 'B'
        return s

    def to_2dstring(self):
        """Give a 2dstring representation of a facelet cube."""
        s = self.to_string()
        r = '   ' + s[0:3] + '\n   ' + s[3:6] + '\n   ' + s[6:9] + '\n'
        r += s[36:39] + s[18:21] + s[9:12] + s[45:48] + '\n' + s[39:42] + s[21:24] + s[12:15] + s[48:51] \
            + '\n' + s[42:45] + s[24:27] + s[15:18] + s[51:54] + '\n'
        r += '   ' + s[27:30] + '\n   ' + s[30:33] + '\n   ' + s[33:36] + '\n'
        return r

    def convert_move(self, s):
        """Convert a move string to a move."""
        s = s.split(' ')
        print(s)
        for move in s:
            if len(move) == 2:
                if move[1] == "2":
                    # recall the move's place
                    move_idx = s.index(move)
                    single_move = move[0]
                    # remove the original 180 degree move
                    s.remove(move)
                    # insert 2 single move in its place
                    s.insert(move_idx, single_move)
                    s.insert(move_idx, single_move)
        return_list = []
        for move in s:
            return_list.append(self.__convert_single_move(move))
        return return_list
    
    def __convert_single_move(self, s):
        if s == 'U':
            return Move.U1
        elif s == 'U\'':
            return Move.U3
        elif s == 'R':
            return Move.R1
        elif s == 'R\'':
            return Move.R3
        elif s == 'F':
            return Move.F1
        elif s == 'F\'':
            return Move.F3
        elif s == 'D':
            return Move.D1
        elif s == 'D\'':
            return Move.D3
        elif s == 'L':
            return Move.L1
        elif s == 'L\'':
            return Move.L3
        elif s == 'B':
            return Move.B1
        elif s == 'B\'':
            return Move.B3
        else:
            return None
    
    def move_list(self, move_list):
        """Perform a list of moves on the facelet cube."""
        for move in move_list:
            self.move(move)
            
    def randomize(self):
        """Randomize the facelet cube."""
        scramble_move = []
        for _ in range(25):
            scramble_move.append(random.choice(list(Move)))
        self.move_list(scramble_move)
        scramble_string = ""
        for move in scramble_move:
            scramble_string += move_dict[move] + " "
        return scramble_string
    
    def randomize_n(self, n):
        """Randomize the facelet cube n times."""
        scramble_move = []
        for _ in range(n):
            scramble_move.append(random.choice(list(Move)))
        self.move_list(scramble_move)
        scramble_string = ""
        for move in scramble_move:
            scramble_string += move_dict[move] + " "
        return scramble_string
    
    def is_solved(self):
        """Check if the facelet cube is solved."""
        for i in range(6):
            for j in range(9):
                if self.f[i * 9] != self.f[i * 9 + j]:
                    return False
        return True
    
    def convert_mlp_input(self):
        temp_list = []
        
        for i in range(54):
            if self.f[i] == 0:
                temp_list.append(0)
            elif self.f[i] == 1:
                temp_list.append(3)
            elif self.f[i] == 2:
                temp_list.append(2)
            elif self.f[i] == 3:
                temp_list.append(5)
            elif self.f[i] == 4:
                temp_list.append(1)
            elif self.f[i] == 5:
                temp_list.append(4)
        
        temp_list = temp_list[0:9] + temp_list[36:45] + temp_list[18:27] + temp_list[9:18]+ temp_list[45:54] + temp_list[27:36]
        color_list = [color_dict[i] for i in temp_list]
        nnet_input = np.array(color_list).reshape(1, -1)[0]
        return nnet_input
        
    def copy(self):
        return np.array(self.f)
    
    
    def convert_res_input(self):
        
        temp_list = []
        for i in range(54):
            if self.f[i] == 0:
                temp_list.append(0)
            elif self.f[i] == 1:
                temp_list.append(3)
            elif self.f[i] == 2:
                temp_list.append(5)
            elif self.f[i] == 3:
                temp_list.append(1)
            elif self.f[i] == 4:
                temp_list.append(2)
            elif self.f[i] == 5:
                temp_list.append(4)
                
        temp_list = temp_list[0:9] + temp_list[27:36] + temp_list[36:45] + temp_list[9:18]+ temp_list[45:54] + temp_list[18:27]
        
        ans_list = []
        
        for i in range(6):
            for element in self.rotate_90(temp_list[i*9:i*9+9]):
                ans_list.append(element)
        
        return np.array(ans_list, dtype=np.uint8)
        
    def rotate_90(self, vector):

        # for every 6 face (9 entries in self.f)
        test_list = [] 
        test_list.append(vector[6])
        test_list.append(vector[3])
        test_list.append(vector[0])
        test_list.append(vector[7])
        test_list.append(vector[4])
        test_list.append(vector[1])
        test_list.append(vector[8])
        test_list.append(vector[5])
        test_list.append(vector[2])
        
        return test_list
    
    def to_colorcube(self):
        pass
    
if __name__ == "__main__":
    cube = FaceCube()
    print(cube.convert_move("U2"))
    cube.move_list(cube.convert_move("R2 F2 L2 U F2 U2 L2 D F2 U2 B2 L' U' B U' F L D' U L2 F'"))
    print(cube.to_2dstring())