from enum import IntEnum
import random
import concurrent.futures
import time
import matplotlib.pyplot as plt


output_file = 'test_kill.txt'

class Facelet(IntEnum):
    """""
    The names of the facelet positions of the cube
                  |************|
                  |*U1**U2**U3*|
                  |************|
                  |*U4**U5**U6*|
                  |************|
                  |*U7**U8**U9*|
                  |************|
     |************|************|************|************|
     |*L1**L2**L3*|*F1**F2**F3*|*R1**R2**R3*|*B1**B2**B3*|
     |************|************|************|************|
     |*L4**L5**L6*|*F4**F5**F6*|*R4**R5**R6*|*B4**B5**B6*|
     |************|************|************|************|
     |*L7**L8**L9*|*F7**F8**F9*|*R7**R8**R9*|*B7**B8**B9*|
     |************|************|************|************|
                  |************|
                  |*D1**D2**D3*|
                  |************|
                  |*D4**D5**D6*|
                  |************|
                  |*D7**D8**D9*|
                  |************|
    A cube definition string "UBL..." means for example: In position U1 we have the U-color, in position U2 we have the
    B-color, in position U3 we have the L color etc. according to the order U1, U2, U3, U4, U5, U6, U7, U8, U9, R1, R2,
    R3, R4, R5, R6, R7, R8, R9, F1, F2, F3, F4, F5, F6, F7, F8, F9, D1, D2, D3, D4, D5, D6, D7, D8, D9, L1, L2, L3, L4,
    L5, L6, L7, L8, L9, B1, B2, B3, B4, B5, B6, B7, B8, B9 of the enum constants.
    """
    U1 = 0
    U2 = 1
    U3 = 2
    U4 = 3
    U5 = 4
    U6 = 5
    U7 = 6
    U8 = 7
    U9 = 8
    R1 = 9
    R2 = 10
    R3 = 11
    R4 = 12
    R5 = 13
    R6 = 14
    R7 = 15
    R8 = 16
    R9 = 17
    F1 = 18
    F2 = 19
    F3 = 20
    F4 = 21
    F5 = 22
    F6 = 23
    F7 = 24
    F8 = 25
    F9 = 26
    D1 = 27
    D2 = 28
    D3 = 29
    D4 = 30
    D5 = 31
    D6 = 32
    D7 = 33
    D8 = 34
    D9 = 35
    L1 = 36
    L2 = 37
    L3 = 38
    L4 = 39
    L5 = 40
    L6 = 41
    L7 = 42
    L8 = 43
    L9 = 44
    B1 = 45
    B2 = 46
    B3 = 47
    B4 = 48
    B5 = 49
    B6 = 50
    B7 = 51
    B8 = 52
    B9 = 53


class Color(IntEnum):
    """ The possible colors of the cube facelets. Color U refers to the color of the U(p)-face etc.
    Also used to name the faces itself."""
    U = 0
    R = 1
    F = 2
    D = 3
    L = 4
    B = 5


class Corner(IntEnum):
    """The names of the corner positions of the cube. Corner URF e.g. has an U(p), a R(ight) and a F(ront) facelet."""
    URF = 0
    UFL = 1
    ULB = 2
    UBR = 3
    DFR = 4
    DLF = 5
    DBL = 6
    DRB = 7


class Edge(IntEnum):
    """The names of the edge positions of the cube. Edge UR e.g. has an U(p) and R(ight) facelet."""
    UR = 0
    UF = 1
    UL = 2
    UB = 3
    DR = 4
    DF = 5
    DL = 6
    DB = 7
    FR = 8
    FL = 9
    BL = 10
    BR = 11


class Move(IntEnum):
    """The moves in the faceturn metric. Not to be confused with the names of the facelet positions in class Facelet."""
    U1 = 0
    U2 = 1
    U3 = 2
    R1 = 3
    R2 = 4
    R3 = 5
    F1 = 6
    F2 = 7
    F3 = 8
    D1 = 9
    D2 = 10
    D3 = 11
    L1 = 12
    L2 = 13
    L3 = 14
    B1 = 15
    B2 = 16
    B3 = 17
    N = 18  # Null move


class BS(IntEnum):
    """Basic symmetries of the cube. All 48 cube symmetries can be generated by sequences of these 4 symmetries."""
    ROT_URF3 = 0
    ROT_F2 = 1
    ROT_U4 = 2
    MIRR_LR2 = 3

# Map the corner positions to facelet positions.
cornerFacelet = [[Facelet.U9, Facelet.R1, Facelet.F3], [Facelet.U7, Facelet.F1, Facelet.L3], [Facelet.U1, Facelet.L1, Facelet.B3], [Facelet.U3, Facelet.B1, Facelet.R3],
                 [Facelet.D3, Facelet.F9, Facelet.R7], [Facelet.D1, Facelet.L9, Facelet.F7], [Facelet.D7, Facelet.B9, Facelet.L7], [Facelet.D9, Facelet.R9, Facelet.B7]
                 ]

# Map the edge positions to facelet positions.
edgeFacelet = [[Facelet.U6, Facelet.R2], [Facelet.U8, Facelet.F2], [Facelet.U4, Facelet.L2], [Facelet.U2, Facelet.B2], [Facelet.D6, Facelet.R8], [Facelet.D2, Facelet.F8],
               [Facelet.D4, Facelet.L8], [Facelet.D8, Facelet.B8], [Facelet.F6, Facelet.R4], [Facelet.F4, Facelet.L6], [Facelet.B6, Facelet.L4], [Facelet.B4, Facelet.R6]
               ]

# Map the corner positions to facelet colors.
cornerColor = [[Color.U, Color.R, Color.F], [Color.U, Color.F, Color.L], [Color.U, Color.L, Color.B], [Color.U, Color.B, Color.R],
               [Color.D, Color.F, Color.R], [Color.D, Color.L, Color.F], [Color.D, Color.B, Color.L], [Color.D, Color.R, Color.B]
               ]

# Map the edge positions to facelet colors.
edgeColor = [[Color.U, Color.R], [Color.U, Color.F], [Color.U, Color.L], [Color.U, Color.B], [Color.D, Color.R], [Color.D, Color.F],
             [Color.D, Color.L], [Color.D, Color.B], [Color.F, Color.R], [Color.F, Color.L], [Color.B, Color.L], [Color.B, Color.R]
             ]

move_dict = {
    Move.U1: "U",
    Move.U2: "U2",
    Move.U3: "U'",
    Move.R1: "R",
    Move.R2: "R2",
    Move.R3: "R'",
    Move.F1: "F",
    Move.F2: "F2",
    Move.F3: "F'",
    Move.D1: "D",
    Move.D2: "D2",
    Move.D3: "D'",
    Move.L1: "L",
    Move.L2: "L2",
    Move.L3: "L'",
    Move.B1: "B",
    Move.B2: "B2",
    Move.B3: "B'",
    Move.N : "N",
}

class FaceCube:
    """Represent a cube on the facelet level with 54 colored facelets."""
    def __init__(self):
        self.f = []
        for i in range(9):
            self.f.append(Color.U)
        for i in range(9):
            self.f.append(Color.R)
        for i in range(9):
            self.f.append(Color.F)
        for i in range(9):
            self.f.append(Color.D)
        for i in range(9):
            self.f.append(Color.L)
        for i in range(9):
            self.f.append(Color.B)

    def __str__(self):
        return self.to_string()
    
    def move(self, move: Move):
        if move == Move.U1:
            # U face
            self._rotate_face(Color.U)
                        
            # adjacent faces
            temp = self.f[Facelet.F1:Facelet.F4]
            self.f[Facelet.F1:Facelet.F4] = self.f[Facelet.R1:Facelet.R4]
            self.f[Facelet.R1:Facelet.R4] = self.f[Facelet.B1:Facelet.B4]
            self.f[Facelet.B1:Facelet.B4] = self.f[Facelet.L1:Facelet.L4]
            self.f[Facelet.L1:Facelet.L4] = temp
        elif move == Move.U2:
            self.move(Move.U1)
            self.move(Move.U1)
        elif move == Move.U3:
            self.move(Move.U1)
            self.move(Move.U1)
            self.move(Move.U1)
            
        elif move == Move.R1:
            # R face
            self._rotate_face(Color.R)
            
            # adjacent faces
            self.f[Facelet.U3], self.f[Facelet.U6], self.f[Facelet.U9], self.f[Facelet.F3], self.f[Facelet.F6], self.f[Facelet.F9], self.f[Facelet.D3], self.f[Facelet.D6], self.f[Facelet.D9], self.f[Facelet.B7], self.f[Facelet.B4], self.f[Facelet.B1] = self.f[Facelet.F3], self.f[Facelet.F6], self.f[Facelet.F9], self.f[Facelet.D3], self.f[Facelet.D6], self.f[Facelet.D9], self.f[Facelet.B7], self.f[Facelet.B4], self.f[Facelet.B1], self.f[Facelet.U3], self.f[Facelet.U6], self.f[Facelet.U9]
        elif move == Move.R2:
            self.move(Move.R1)
            self.move(Move.R1)
        elif move == Move.R3:
            self.move(Move.R1)
            self.move(Move.R1)
            self.move(Move.R1)
            
        elif move == Move.F1:
            # F face
            self._rotate_face(Color.F)
            
            # adjacent faces
            self.f[Facelet.U7], self.f[Facelet.U8], self.f[Facelet.U9], self.f[Facelet.R1], self.f[Facelet.R4], self.f[Facelet.R7], self.f[Facelet.D1], self.f[Facelet.D2], self.f[Facelet.D3], self.f[Facelet.L3], self.f[Facelet.L6], self.f[Facelet.L9] = self.f[Facelet.L9], self.f[Facelet.L6], self.f[Facelet.L3], self.f[Facelet.U7], self.f[Facelet.U8], self.f[Facelet.U9], self.f[Facelet.R7], self.f[Facelet.R4], self.f[Facelet.R1], self.f[Facelet.D1], self.f[Facelet.D2], self.f[Facelet.D3]
        elif move == Move.F2:
            self.move(Move.F1)
            self.move(Move.F1)
        elif move == Move.F3:
            self.move(Move.F1)
            self.move(Move.F1)
            self.move(Move.F1)
            
        # D moves
        elif move == Move.D1:
            # D face
            self._rotate_face(Color.D)
            
            # adjacent faces
            temp = self.f[Facelet.F7], self.f[Facelet.F8], self.f[Facelet.F9]
            self.f[Facelet.F7], self.f[Facelet.F8], self.f[Facelet.F9] = self.f[Facelet.L7], self.f[Facelet.L8], self.f[Facelet.L9]
            self.f[Facelet.L7], self.f[Facelet.L8], self.f[Facelet.L9] = self.f[Facelet.B7], self.f[Facelet.B8], self.f[Facelet.B9]
            self.f[Facelet.B7], self.f[Facelet.B8], self.f[Facelet.B9] = self.f[Facelet.R7], self.f[Facelet.R8], self.f[Facelet.R9]
            self.f[Facelet.R7], self.f[Facelet.R8], self.f[Facelet.R9] = temp
        elif move == Move.D2:
            self.move(Move.D1)
            self.move(Move.D1)
        elif move == Move.D3:
            self.move(Move.D1)
            self.move(Move.D1)
            self.move(Move.D1)
            
        # L moves
        elif move == Move.L1:
            # L face
            self._rotate_face(Color.L)
            
            # adjacent faces
            temp = [self.f[Facelet.U1], self.f[Facelet.U4], self.f[Facelet.U7]]
            self.f[Facelet.U1], self.f[Facelet.U4], self.f[Facelet.U7] = self.f[Facelet.B9], self.f[Facelet.B6], self.f[Facelet.B3]
            self.f[Facelet.B9], self.f[Facelet.B6], self.f[Facelet.B3] = self.f[Facelet.D1], self.f[Facelet.D4], self.f[Facelet.D7]
            self.f[Facelet.D1], self.f[Facelet.D4], self.f[Facelet.D7] = self.f[Facelet.F1], self.f[Facelet.F4], self.f[Facelet.F7]
            self.f[Facelet.F1], self.f[Facelet.F4], self.f[Facelet.F7] = temp
        elif move == Move.L2:
            self.move(Move.L1)
            self.move(Move.L1)
        elif move == Move.L3:
            self.move(Move.L1)
            self.move(Move.L1)
            self.move(Move.L1)
            
        # B moves
        elif move == Move.B1:
            # B face
            self._rotate_face(Color.B)
            
            # adjacent faces
            temp = [self.f[Facelet.U1], self.f[Facelet.U2], self.f[Facelet.U3]]
            self.f[Facelet.U1], self.f[Facelet.U2], self.f[Facelet.U3] = self.f[Facelet.R3], self.f[Facelet.R6], self.f[Facelet.R9]
            self.f[Facelet.R3], self.f[Facelet.R6], self.f[Facelet.R9] = self.f[Facelet.D9], self.f[Facelet.D8], self.f[Facelet.D7]
            self.f[Facelet.D9], self.f[Facelet.D8], self.f[Facelet.D7] = self.f[Facelet.L7], self.f[Facelet.L4], self.f[Facelet.L1]
            self.f[Facelet.L7], self.f[Facelet.L4], self.f[Facelet.L1] = temp
        elif move == Move.B2:
            self.move(Move.B1)
            self.move(Move.B1)
        elif move == Move.B3:
            self.move(Move.B1)
            self.move(Move.B1)
            self.move(Move.B1)
            
        elif move == Move.N:
            pass
        
        else:
            return 'Error: Invalid move ' + str(move)
        
    def _rotate_face(self, face):
        """Rotate a face clockwise."""
        offset = face * 9
        new_f = self.f[offset:offset+9]  # Copy the face
        self.f[offset + 0] = new_f[6]
        self.f[offset + 2] = new_f[0]
        self.f[offset + 6] = new_f[8]
        self.f[offset + 8] = new_f[2]
        
        self.f[offset + 1] = new_f[3]
        self.f[offset + 3] = new_f[7]
        self.f[offset + 5] = new_f[1]
        self.f[offset + 7] = new_f[5]
            
    def from_string(self, s):
        """Construct a facelet cube from a string. See class Facelet(IntEnum) in enums.py for string format."""
        if len(s) < 54:
            return 'Error: Cube definition string ' + s + ' contains less than 54 facelets.'
        elif len(s) > 54:
            return 'Error: Cube definition string ' + s + ' contains more than 54 facelets.'
        cnt = [0] * 6
        for i in range(54):
            if s[i] == 'U':
                self.f[i] = Color.U
                cnt[Color.U] += 1
            elif s[i] == 'R':
                self.f[i] = Color.R
                cnt[Color.R] += 1
            elif s[i] == 'F':
                self.f[i] = Color.F
                cnt[Color.F] += 1
            elif s[i] == 'D':
                self.f[i] = Color.D
                cnt[Color.D] += 1
            elif s[i] == 'L':
                self.f[i] = Color.L
                cnt[Color.L] += 1
            elif s[i] == 'B':
                self.f[i] = Color.B
                cnt[Color.B] += 1
        if all(x == 9 for x in cnt):
            return True
        else:
            return 'Error: Cube definition string ' + s + ' does not contain exactly 9 facelets of each color.'

    def to_string(self):
        """Give a string representation of the facelet cube."""
        s = ''
        for i in range(54):
            if self.f[i] == Color.U:
                s += 'U'
            elif self.f[i] == Color.R:
                s += 'R'
            elif self.f[i] == Color.F:
                s += 'F'
            elif self.f[i] == Color.D:
                s += 'D'
            elif self.f[i] == Color.L:
                s += 'L'
            elif self.f[i] == Color.B:
                s += 'B'
        return s

    def to_2dstring(self):
        """Give a 2dstring representation of a facelet cube."""
        s = self.to_string()
        r = '   ' + s[0:3] + '\n   ' + s[3:6] + '\n   ' + s[6:9] + '\n'
        r += s[36:39] + s[18:21] + s[9:12] + s[45:48] + '\n' + s[39:42] + s[21:24] + s[12:15] + s[48:51] \
            + '\n' + s[42:45] + s[24:27] + s[15:18] + s[51:54] + '\n'
        r += '   ' + s[27:30] + '\n   ' + s[30:33] + '\n   ' + s[33:36] + '\n'
        return r

    def convert_move(self, s):
        """Convert a move string to a move."""
        s = s.split(' ')
        return_list = []
        for move in s:
            if s != 'N':
                return_list.append(self.__convert_single_move(move))
        return return_list
    
    def __convert_single_move(self, s):
        if s == 'U':
            return Move.U1
        elif s == 'U2':
            return Move.U2
        elif s == 'U\'':
            return Move.U3
        elif s == 'R':
            return Move.R1
        elif s == 'R2':
            return Move.R2
        elif s == 'R\'':
            return Move.R3
        elif s == 'F':
            return Move.F1
        elif s == 'F2':
            return Move.F2
        elif s == 'F\'':
            return Move.F3
        elif s == 'D':
            return Move.D1
        elif s == 'D2':
            return Move.D2
        elif s == 'D\'':
            return Move.D3
        elif s == 'L':
            return Move.L1
        elif s == 'L2':
            return Move.L2
        elif s == 'L\'':
            return Move.L3
        elif s == 'B':
            return Move.B1
        elif s == 'B2':
            return Move.B2
        elif s == 'B\'':
            return Move.B3
        elif s == 'N':
            return Move.N
        else:
            return None
    
    def move_list(self, move_list):
        """Perform a list of moves on the facelet cube."""
        for move in move_list:
            self.move(move)
            
    def randomize(self):
        """Randomize the facelet cube."""
        scramble_move = []
        for _ in range(7):
            scramble_move.append(random.choice(list(Move)))
        self.move_list(scramble_move)
        scramble_string = ""
        for move in scramble_move:
            scramble_string += move_dict[move] + " "
        return scramble_string
            

# Genetic Algorithm Parameters
POPULATION_SIZE = 800
NUM_GENERATIONS = 1000
TOURNAMENT_SIZE = 100
MUTATION_RATE = 0.3
SEQUENCE_LENGTH = 7

def generate_individual():
    """Generate a random individual solution."""
    return [random.choice(list(Move)) for _ in range(SEQUENCE_LENGTH)]

def compute_fitness(scrambled_str, individual):
    cube = FaceCube()
    cube.from_string(scrambled_str)
    cube.move_list(individual)
    
    """Compute the fitness of an individual solution."""
    # Initialize a solved cube
    solved_cube = FaceCube()
    # Apply the sequence of moves from the individual to a new cube
    
    # Compare each subface to the solved state
    correct_subfaces = sum(1 for i in range(54) if cube.f[i] == solved_cube.f[i])
    return correct_subfaces

def crossover(parent1, parent2):
    """Perform crossover between two parents to produce two offspring."""
    crossover_point = random.randint(0, SEQUENCE_LENGTH - 1)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

def mutate(individual):
    """Mutate an individual's genes."""
    for i in range(SEQUENCE_LENGTH):
        if random.random() < MUTATION_RATE:
            individual[i] = random.choice(list(Move))
    return individual

def tournament_selection(population, scores):
    """Select one individual using tournament selection."""
    tournament = random.sample(list(zip(population, scores)), TOURNAMENT_SIZE)
    tournament.sort(key=lambda x: x[1], reverse=True)  # Sort by fitness in descending order
    return tournament[0][0]


def kill_by_rank(population, survival_rate=0.5):
    # Calculate fitness for each individual
    scored_population = [(individual, compute_fitness(scrambled_str, individual)) for individual in population]
    
    # Rank population by fitness
    scored_population.sort(key=lambda x: x[1], reverse=True)  # Sort by fitness in descending order
    
    # Select survivors based on survival rate
    num_survivors = int(len(population) * survival_rate)
    survivors = scored_population[:num_survivors]
    
    # Generate offspring
    offspring = []
    while len(offspring) < (len(population) - num_survivors):
        parent1, parent2 = random.sample([individual for individual, _ in survivors], 2)
       
        child1, child2 = crossover(parent1, parent2)
        offspring.append(mutate(child1))
        if len(offspring) < (len(population) - num_survivors):
            offspring.append(mutate(child2))
    
    # Create new population by combining survivors and offspring
    new_population = [individual for individual, _ in survivors] + offspring
    return new_population

# Main GA Loop
def genetic_algorithm(scrambled_str):
    population = [generate_individual() for _ in range(POPULATION_SIZE)]
    # Training loop
    plt.ion()
    fig, ax = plt.subplots(figsize=(10, 6))
    best_fitnesses = []
    
    index = 0
    while True:
        population = kill_by_rank(population)
        
        # Optional: Evaluate and print the best fitness in the current generation
        best_fitness = max(compute_fitness(scrambled_str, individual) for individual in population)
        
        best_fitnesses.append(best_fitness)
        
        ax.clear()
        ax.plot(best_fitnesses, label='Training Best Fitnesses')
        ax.set_xlabel('Generation')
        ax.set_ylabel('Fitness')
        ax.set_title('Best Fitnesses Over Generations')
        ax.legend()
        fig.canvas.draw()
        fig.canvas.flush_events()

            
        if best_fitness == 54:
            with open(output_file, 'a') as f:
                f.write("Solution found!\n")
                print("Solution found!")
                best_individual = max(population, key=lambda individual: compute_fitness(scrambled_str, individual))
                best_str = ""
                for move in best_individual:
                    best_str += move_dict[move] + " "
                    
                print("Best solution:", best_str)
                f.write(best_str)
                break
            
        with open(output_file, 'a') as f:
            f.write(f"Generation {index + 1}: Best Fitness = {best_fitness}\n")
        print(f"Generation {index + 1}: Best Fitness = {best_fitness}")
        index += 1
    else:
        with open(output_file, 'a') as f:
            f.write("No solution found.\n")
        print("No solution found.")
        
    # Save the plot
    plt.savefig(f"GA/loss.png")
    plt.ioff()
    plt.show()

# Run the GA
if __name__ == "__main__":
    scrambled_cube = FaceCube()
    with open(output_file, 'w') as f:
        f.write(scrambled_cube.randomize())
        f.write('\n')
        f.write(scrambled_cube.to_2dstring())
        
    scrambled_str = scrambled_cube.to_string()

    print("Scrambled cube:")
    print(scrambled_cube.to_2dstring())
    
    genetic_algorithm(scrambled_str)
    
    